#+SETUPFILE: ~/sources/org-html-themes/setup/theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
#+TITLE: Terraform Study Group

* Goals
  - [[https://www.hashicorp.com/certification/terraform-associate][Hashicorp: Terraform Certificate]]
* Schedule
* Topics
** 1   Understand infrastructure as code (IaC) concepts
*** 1a   Explain what IaC is
    - Programmable infrastructure
    - Different kind of interfaces
    - Infrastructure defined as code
*** 1b   Describe advantages of IaC patterns
    - IaC source acts as documentation
      - can be statically analyzed etc
      - easier to share information about the infrastructure
    - Declarative
    - Version controlled
    - Velocity
      - Faster changes
        - no need to wait for the infra guy to push button etc?
*** Other notes
**** not so declarative:
      - may be esoteric calls to remote repositories

** 2   Understand Terraform's purpose (vs other IaC)

*** 2a   Explain multi-cloud and provider-agnostic benefits
    - Unified methodology to managing resources
      - declarative language describes everything
    - Multicloud
      - AZURE, AWS, GCP etc..
    - Same tool can describe resources in various cloud environments
    - provider: "Managed Binary"

*** 2b   Explain the benefits of state
    - What if there were no state?
    - Can diff between infrastructure declaration versus actual state of the infrastructure
    - Can plan in advance the changes by inspecting the diff
    - what if the state gets too big?
      - doing small changes...
    - benefits of partitioning state?
    - techniques to partition state?
    - What is the state gets corrupted?

*** Ansible vs. Cloudfront vs. Terraform
    - Ansible is imperative
    - Ansible is a configuration management tool, [[https://www.reddit.com/r/devops/comments/lqk92n/you_are_on_an_island_and_can_only_have_terraform/gohlusl/?utm_source=reddit&utm_medium=web2x&context=3][ref]]
    - Ansible is for hugging machines
      - Kimmo could explain what this means? :D

** 3   Understand Terraform basics
*** 3a   Handle Terraform and provider installation and versioning
    - can be configured as required providers and inlining version to provider
    - define provider block
    - terraform init
      - download binaries for the providers, etc "aws"

*** 3b   Describe plugin based architecture
    - Revisit this one

**** What is a plugin (the binary)
     Terraform Plugins: These are executable binaries written in Go that communicate
     with Terraform Core over an RPC interface. Each plugin exposes an implementation
     for a specific service, such as the AWS provider or the cloud-init provider.
     Terraform currently supports one type of Plugin called providers.

*** 3c   Demonstrate using multiple providers

    - With AWS might be required to use multiple regions

    #+begin_src terraform
provider "aws" {
  alias   = "aws"
  region  = "eu-west-1"
  version = "~> 2.70.0"
}


provider "aws" {
  alias   = "aws_certificate"
  region  = "us-east-1"
  version = "~> 2.70.0"
}
    #+end_src

    - Multiple different platforms communicating together
      - e.g. Auth0 + AWS + Heroku

*** 3d   Describe how Terraform finds and fetches providers
    - terraform init
    - looks plugins defined in providers from:
      - public TF registry or in 3rd party provider registry
      - local mirror or cache

*** 3e   Explain when to use and not use provisioners and when to use local-exec or remote-exec
    - run local script on terraform apply
 #+begin_src terraform
resource "aws_instance" "web" {
  # ...

  provisioner "local-exec" {
    command = "echo ${self.private_ip} >> private_ips.txt"
  }
}

 #+end_src
    - remote-exec:
      - run scripts in deployed VM's
#+begin_src terraform
resource "aws_instance" "web" {
  # ...

  provisioner "file" {
    source      = "script.sh"
    destination = "/tmp/script.sh"
  }

  provisioner "remote-exec" {
    inline = [
      "chmod +x /tmp/script.sh",
      "/tmp/script.sh args",
    ]
  }
}
#+end_src

** 4   Use the Terraform CLI (outside of core workflow)
*** 4a   Given a scenario: choose when to use terraform fmt to format code
    - Whenever the code is edited
    - Can be used as a linting tool in CI
      - =terraform fmt -recursive -diff=
      -


*** 4b   Given a scenario: choose when to use terraform taint to taint Terraform resources
    - TODO: test taint, what happens to resource and state before after...
    - Need to regenerate an access token or a key
    - considered as deprecated
      - should use =terraform apply -replace= instead

        #+BEGIN_QUOTE
        Creating a plan with the "replace" option is superior to using terraform taint because
        it will allow you to see the full effect of that change before you take any externally-visible
        action. When you use terraform taint to get a similar effect, you risk someone else on your
        team creating a new plan against your tainted object before you've had a chance to review the
        consequences of that change yourself. [[https://www.terraform.io/docs/cli/commands/taint.html][command: taint]]
        #+END_QUOTE

        #+begin_quote
        The address argument is the address of the resource to mark as tainted.
        The address is in the resource address syntax syntax, as shown in the
        output from other commands
        #+end_quote

*** 4c   Given a scenario: choose when to use terraform import to import existing infrastructure into your Terraform state
    - Incremental adoption
    - Migrating existing infrastructure under terraform
    - Import is possible only into state
      - the configuration (code) can not be generated
        #+begin_quote
        Because of this, prior to running terraform import it is necessary to write manually a resource
        configuration block for the resource, to which the imported object will be mapped.
        [[https://www.terraform.io/docs/cli/import/index.html][command: import]]
        #+end_quote

*** 4d   Given a scenario: choose when to use terraform workspace to create workspaces
    - When two or more isolated states are needed
    - To isolate infrastructure
    -
      #+begin_src
      In Terraform CLI, workspaces are separate instances of state data that can be used from the same working directory.
      You can use workspaces to manage multiple non-overlapping groups of resources with the same configuration.
      #+end_src
      [[https://www.terraform.io/docs/cli/workspaces/index.html][terraform: workspace]]

*** 4e   Given a scenario: choose when to use terraform state to view Terraform state
    - Inspecting state (find credentials/access keys/etc)
    - Debugging: not sure if some value has propagated correctly all the way to the resource
    - Fix corrupted state

*** 4f   Given a scenario: choose when to enable verbose logging and what the outcome/value is
    - Debugging
    #+begin_quote
    You can set TF_LOG to one of the log levels TRACE, DEBUG, INFO, WARN or ERROR to change the verbosity of the logs.
    #+end_quote
    [[https://www.terraform.io/docs/internals/debugging.html ][terraform: debugging]]

** 5   Interact with Terraform modules
*** 5a   Contrast module source options
*** 5b   Interact with module inputs and outputs
*** 5c   Describe variable scope within modules/child modules
*** 5d   Discover modules from the public Terraform Module Registry
*** 5e   Defining module version
** 6   Navigate Terraform workflow
*** 6a   Describe Terraform workflow ( Write -> Plan -> Create )
*** 6b   Initialize a Terraform working directory (terraform init)
*** 6c   Validate a Terraform configuration (terraform validate)
*** 6d   Generate and review an execution plan for Terraform (terraform plan)
*** 6e   Execute changes to infrastructure with Terraform (terraform apply)
*** 6f   Destroy Terraform managed infrastructure (terraform destroy)
** 7   Implement and maintain state
*** 7a   Describe default local backend
*** 7b   Outline state locking
*** 7c   Handle backend authentication methods
*** 7d   Describe remote state storage mechanisms and supported standard backends
*** 7e   Describe effect of Terraform refresh on state
*** 7f   Describe backend block in configuration and best practices for partial configurations
*** 7g   Understand secret management in state files
** 8   Read, generate, and modify configuration
*** 8a   Demonstrate use of variables and outputs
*** 8b   Describe secure secret injection best practice
*** 8c   Understand the use of collection and structural types
*** 8d   Create and differentiate resource and data configuration
*** 8e   Use resource addressing and resource parameters to connect resources together
*** 8f   Use Terraform built-in functions to write configuration
*** 8g   Configure resource using a dynamic block
*** 8h   Describe built-in dependency management (order of execution based)
** 9   Understand Terraform Cloud and Enterprise capabilities
*** 9a   Describe the benefits of Sentinel, registry, and workspaces
*** 9b   Differentiate OSS and TFE workspaces
*** 9c   Summarize features of Terraform Cloud
